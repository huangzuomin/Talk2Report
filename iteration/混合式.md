这是一个非常扎实的工程挑战。要实现**“混合式”（Hybrid）**架构——即**“基于槽位（Slot-Filling）状态机的动态访谈”**，我们需要将之前的纯线性或纯发散逻辑，重构为一个**闭环的状态管理系统**。

核心思想：**把“对话”变成“填空游戏”。** 前端维护一份“答卷”，每次对话都是为了把答卷里的空填上。

以下是完整的工程解决方案，涵盖数据结构、工作流逻辑、Prompt 设计和前端交互。

---

### 1. 核心数据结构：槽位定义 (The Schema)

这是整个系统的“骨架”。我们需要定义一份 JSON，它既是后端存储的数据，也是前端展示进度的依据。

**`ReportState.json` (定义在前端或 BFF 层)**

```typescript
interface ReportSlot {
  key: string;          // 字段ID
  label: string;        // 前端显示的标题
  description: string;  // 给 AI 的提取说明
  value: string | null; // 提取到的内容 (null 表示未填)
  required: boolean;    // 是否必填 (用于决定是否必须追问)
  status: 'empty' | 'partial' | 'complete'; // 状态
}

// 初始状态定义
const INITIAL_STATE = {
  slots: [
    {
      key: "achievement_highlight",
      label: "核心业绩",
      description: "本年度最重要的一个项目或成果，需包含项目名。",
      value: null,
      required: true
    },
    {
      key: "metrics",
      label: "量化指标",
      description: "具体的数字、百分比、节约的时间或金钱。",
      value: null,
      required: true
    },
    {
      key: "challenges",
      label: "困难克服",
      description: "遇到的最大阻碍及解决手段。",
      value: null,
      required: true
    },
    {
      key: "growth",
      label: "个人成长",
      description: "新技能、认知提升或方法论沉淀。",
      value: null,
      required: false // 选填，AI会尝试问，但用户想跳过也行
    },
    {
      key: "future_plan",
      label: "明年规划",
      description: "明年的目标或需要的支持。",
      value: null,
      required: true
    }
  ],
  conversation_round: 0, // 当前轮次
  is_finished: false     // 是否结束访谈
};

```

---

### 2. 架构流程图 (The Workflow)

我们需要一个 **"提取 - 更新 - 决策" (Extract-Update-Decide)** 的循环。

* **User Input**: 用户发送消息。
* **Step 1: Extract (Agent B - DeepSeek V3)**: 看着用户的消息和当前的 `slots`，提取信息，更新 `value`。
* **Step 2: Update State**: 将提取到的值回写到 JSON。
* **Step 3: Decide (Rule Engine)**: 检查 `required` 字段是否都有值了？或者轮次是否超标？ -> 决定是否结束。
* **Step 4: Ask (Agent A - DeepSeek R1)**: 如果没结束，看着剩下的 `null` 槽位，生成下一个问题。

---

### 3. 详细实现步骤

#### 步骤一：配置 Agent B (Extractor / 填槽者)

* **模型**: DeepSeek-V3 (速度快，JSON 遵循能力强)
* **任务**: 只负责从对话中“抠字眼”，不负责陪聊。

**System Prompt:**

```markdown
# Role
你是一个数据提取员。你的任务是根据用户的回复，提取信息填入指定的 JSON Slots 中。

# Context
当前 Slots 状态:
{{JSON.stringify(slots)}}

# User Input
{{user_message}}

# Instructions
1. 分析用户的输入，看是否包含任何 Slot 的信息。
2. 如果包含，提取并总结内容（不要照搬原话，要精简为事实）。
3. 如果不包含，保持原值。
4. **只输出 JSON**，格式如下：
{
  "updates": [
    { "key": "metrics", "value": "提升了30%的并发处理能力" }
  ]
}
如果没有新信息，输出 {"updates": []}。

```

#### 步骤二：配置 Agent A (Interviewer / 提问者)

* **模型**: DeepSeek-R1 (推理能力强，负责话术策略)
* **任务**: 看着还有哪些坑没填，决定怎么问。

**System Prompt:**

```markdown
# Role
你是一名职业咨询师。

# Goal
你的目标是填满以下“缺失槽位”。
当前缺失: {{missing_slots_list}}
已收集信息: {{filled_slots_summary}}

# Constraints
1. 每次 **只针对 1 个** 最重要的缺失槽位提问。不要贪多。
2. 结合“已收集信息”进行追问。例如：如果已知“核心业绩”是“重构系统”，但缺“量化指标”，你应该问：“这个重构系统上线后，性能具体提升了多少？”
3. 语气要自然、专业、鼓励性。
4. 如果缺失的是“量化指标”，请引导用户提供具体数字或对比。

# Output
直接输出给用户的回复文本。

```

#### 步骤三：前端状态管理 (React Hook)

前端不再只是傻傻地发消息，它需要维护 `ReportState`。

```javascript
// useInterviewMachine.js

export const useInterviewMachine = () => {
  const [state, setState] = useState(INITIAL_STATE);
  const [messages, setMessages] = useState([]);

  const sendMessage = async (userText) => {
    // 1. 本地 UI 更新用户消息
    addMessageToUI('user', userText);

    // 2. 发送给 n8n (携带当前状态！)
    // 注意：我们将状态维护放在前端/BFF，n8n 变成无状态的计算节点，这样更稳健
    const payload = {
      message: userText,
      currentSlots: state.slots,
      history: messages.slice(-5) // 只传最近几轮，省 token
    };

    const response = await fetch('/api/chat/hybrid-flow', {
      method: 'POST',
      body: JSON.stringify(payload)
    });

    const data = await response.json();

    // 3. 接收 n8n 返回的“提取结果”和“下一个问题”
    // data = { updates: [...], nextQuestion: "...", isFinished: boolean }

    // 4. 更新本地状态 (填槽)
    if (data.updates) {
      const newSlots = state.slots.map(slot => {
        const update = data.updates.find(u => u.key === slot.key);
        return update ? { ...slot, value: update.value, status: 'complete' } : slot;
      });
      setState(prev => ({ ...prev, slots: newSlots }));
    }

    // 5. 显示 AI 回复
    addMessageToUI('assistant', data.nextQuestion);
  };

  return { state, messages, sendMessage };
};

```

#### 步骤四：前端 UI 可视化 (The "Scaffold")

为了让用户感知到“可控性”，不要只放一个对话框。

**布局建议：**

* **左侧 (70%)**: 聊天窗口 (Chat UI)。
* **右侧 (30%)**: **素材收集板 (The Dashboard)**。

**素材收集板组件：**

```jsx
<div className="card">
  <h3>📊 总结完成度</h3>
  {state.slots.map(slot => (
    <div key={slot.key} className={`slot-item ${slot.status}`}>
      <div className="icon">
        {slot.status === 'complete' ? '✅' : '⭕️'}
      </div>
      <div className="content">
        <span className="label">{slot.label}</span>
        {/* 当槽位填好后，显示摘要，给用户获得感 */}
        {slot.value && <span className="value text-xs text-gray-500">{slot.value}</span>}
      </div>
    </div>
  ))}
</div>

```

*当 DeepSeek 提取到数据，右侧的圈圈瞬间变成绿色的勾，这种即时反馈会极大地激励用户继续聊下去。*

---

### 4. 异常处理与降级 (Safety Valve)

**问题**：如果 R1 一直问不出来怎么办？或者用户就是不想答“量化指标”？

**解决方案：跳过机制**

1. **AI 判别**：如果用户回复“不知道”、“没数据”、“跳过”，Agent B (Extractor) 应该提取出一个特殊标记：`value: "SKIPPED"`。
2. **状态更新**：该槽位被标记为 `complete` (但内容为空)，系统继续寻找下一个 `null` 槽位。
3. **前端按钮**：在输入框上方常驻一个 `[跳过此问题]` 按钮，点击后直接发送指令给后端，强制跳过当前聚焦的槽位。

### 5. 总结工程优势

这套“混合式”方案的工程实现：

1. **解耦**：前端负责状态持有，AI 负责状态转换。
2. **容错**：即使提取失败，用户也可以手动修正（未来功能：允许用户点击右侧面板直接修改提取错误的槽位）。
3. **可测**：你可以写单元测试——输入一段话，检查 JSON Slot 是否正确更新。
4. **DeepSeek 友好**：
* **V3** 负责繁琐的 JSON 提取（便宜、快）。
* **R1** 负责高智商的追问（贵、慢、但质量高）。
* 两者各司其职。